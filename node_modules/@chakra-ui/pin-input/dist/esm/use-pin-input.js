function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { useDescendants, useDescendant } from "@chakra-ui/descendant";
import { useControllableState, useId } from "@chakra-ui/hooks";
import { mergeRefs, callAllHandlers, createContext, ariaAttr } from "@chakra-ui/utils";
import { useState, useEffect, useRef, useCallback } from "react";
var [PinInputProvider, usePinInputContext] = createContext({
  name: "PinInputContext",
  errorMessage: "usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`"
});
export { PinInputProvider, usePinInputContext };

function toArray(value) {
  if (typeof value === "string") {
    return value.split("");
  }

  return undefined;
}

export function usePinInput(props) {
  if (props === void 0) {
    props = {};
  }

  var {
    autoFocus,
    value,
    defaultValue,
    onChange: _onChange,
    onComplete,
    placeholder = "â—‹",
    manageFocus = true,
    id: idProp,
    isDisabled,
    isInvalid
  } = props;
  var uuid = useId();
  var id = idProp != null ? idProp : "pin-input-" + uuid;
  var domContext = useDescendants();
  var {
    descendants
  } = domContext;
  var [moveFocus, setMoveFocus] = useState(true);
  var [values, setValues] = useControllableState({
    defaultValue: toArray(defaultValue) || [],
    value: toArray(value),
    onChange: values => _onChange == null ? void 0 : _onChange(values.join(""))
  });
  useEffect(() => {
    if (autoFocus) {
      var _firstInput$element;

      var firstInput = descendants[0];
      firstInput == null ? void 0 : (_firstInput$element = firstInput.element) == null ? void 0 : _firstInput$element.focus();
    }
  }, [descendants, autoFocus]);
  var focusNext = useCallback(index => {
    var _nextInput$element;

    if (!moveFocus || !manageFocus) return;
    var nextInput = descendants[index + 1];
    nextInput == null ? void 0 : (_nextInput$element = nextInput.element) == null ? void 0 : _nextInput$element.focus();
  }, [descendants, moveFocus, manageFocus]);
  var setValue = useCallback((value, index) => {
    var nextValues = [...values];
    nextValues[index] = value;
    setValues(nextValues); // if we're at the last input, call onComplete (no need to move focus)

    if (index === descendants.length - 1) {
      onComplete == null ? void 0 : onComplete(nextValues.join(""));
    } else {
      focusNext(index);
    }
  }, [values, setValues, focusNext, onComplete, descendants.length]);
  var clear = useCallback(() => {
    var _firstInput$element2;

    var values = Array(descendants.length).fill("");
    setValues(values);
    var firstInput = descendants[0];
    (_firstInput$element2 = firstInput.element) == null ? void 0 : _firstInput$element2.focus();
  }, [descendants, setValues]);
  return {
    id,
    domContext,
    setValue,
    values,
    setValues,
    setMoveFocus,
    clear,
    onComplete,
    placeholder,
    manageFocus,
    isDisabled,
    isInvalid
  };
}
export function usePinInputField(props) {
  if (props === void 0) {
    props = {};
  }

  var {
    ref: forwardedRef
  } = props,
      rest = _objectWithoutPropertiesLoose(props, ["ref"]);

  var ref = useRef(null);
  var {
    id,
    isDisabled,
    isInvalid,
    setValue,
    values,
    setMoveFocus,
    setValues,
    domContext,
    placeholder,
    manageFocus
  } = usePinInputContext();
  var {
    descendants
  } = domContext;
  var index = useDescendant({
    context: domContext,
    element: ref.current
  });
  var getNextValue = useCallback((currentValue, eventValue) => {
    var nextValue = eventValue;

    if (currentValue && currentValue.length > 0) {
      var [firstValue, secondValue] = eventValue;

      if (currentValue[0] === firstValue) {
        nextValue = secondValue;
      } else if (currentValue[0] === secondValue) {
        nextValue = firstValue;
      }
    }

    return nextValue;
  }, []); // Improved from: https://github.com/uber/baseweb/blob/master/src/pin-code/pin-code.js

  var onChange = useCallback(event => {
    var eventValue = event.target.value;
    var currentValue = values[index];
    var nextValue = getNextValue(currentValue, eventValue); // if the value was removed using backspace

    if (nextValue === "") {
      setValue("", index);
      return;
    } // in the case of an autocomplete or copy and paste


    if (eventValue.length > 2) {
      // see if we can use the string to fill out our values
      if (eventValue.match(/^[0-9]+$/)) {
        var {
          length
        } = descendants; // ensure the value matches the number of inputs

        var _nextValue = eventValue.split("").filter((_, i) => i < length);

        setValues(_nextValue);
      }

      return;
    } // only set if the new value is a number


    if (nextValue.match(/^[0-9]$/)) {
      setValue(nextValue, index);
    }

    setMoveFocus(true);
  }, [values, index, getNextValue, setMoveFocus, setValue, descendants.length, setValues]);
  var onKeyDown = useCallback(event => {
    if (event.key === "Backspace" && manageFocus) {
      if (event.target.value === "") {
        var prevInput = descendants[index - 1];

        if (prevInput) {
          var _prevInput$element;

          setValue("", index - 1);
          (_prevInput$element = prevInput.element) == null ? void 0 : _prevInput$element.focus();
          setMoveFocus(true);
        }
      } else {
        setMoveFocus(false);
      }
    }
  }, [descendants, index, setValue, setMoveFocus, manageFocus]);
  var [hasFocus, setHasFocus] = useState(false);
  var onFocus = useCallback(() => {
    setHasFocus(true);
  }, []);
  var onBlur = useCallback(() => {
    setHasFocus(false);
  }, []);
  return _extends({}, rest, {
    id: id + "-" + index,
    disabled: isDisabled,
    "aria-invalid": ariaAttr(isInvalid),
    ref: mergeRefs(ref, forwardedRef),
    onChange: callAllHandlers(rest.onChange, onChange),
    onKeyDown: callAllHandlers(rest.onKeyDown, onKeyDown),
    onFocus: callAllHandlers(rest.onFocus, onFocus),
    onBlur: callAllHandlers(rest.onBlur, onBlur),
    value: values[index] || "",
    inputMode: "numeric",
    "aria-label": rest["aria-label"] || "Please enter your pin code",
    autoComplete: "not-allowed",
    placeholder: hasFocus ? "" : placeholder
  });
}
//# sourceMappingURL=use-pin-input.js.map