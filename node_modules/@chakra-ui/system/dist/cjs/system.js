"use strict";

exports.__esModule = true;
exports.styled = styled;
exports.chakra = exports.styleResolver = void 0;

var _styledSystem = require("@chakra-ui/styled-system");

var _utils = require("@chakra-ui/utils");

var _styled = _interopRequireDefault(require("@emotion/styled"));

var _shouldForwardProp = require("./should-forward-prop");

var _system = require("./system.utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Convert propNames array to object to faster lookup perf
 */
var stylePropNames = _styledSystem.propNames.reduce(function (keymirror, key) {
  if (typeof key !== "object" && typeof key !== "function") keymirror[key] = key;
  return keymirror;
}, {});

/**
 * Style resolver function that manages how style props are merged
 * in combination with other possible ways of defining styles.
 *
 * For example, take a component defined this way:
 * ```jsx
 * <Box fontSize="24px" sx={{ fontSize: "40px" }}></Box>
 * ```
 *
 * We want to manage the priority of the styles properly to prevent unwanted
 * behaviors. Right now, the `sx` prop has the highest priority so the resolved
 * fontSize will be `40px`
 */
var styleResolver = function styleResolver(_ref) {
  var baseStyle = _ref.baseStyle;
  return function (props) {
    var theme = props.theme,
        layerStyle = props.layerStyle,
        textStyle = props.textStyle,
        apply = props.apply,
        noOfLines = props.noOfLines,
        isTruncated = props.isTruncated,
        cssProp = props.css,
        __css = props.__css,
        sx = props.sx,
        rest = _objectWithoutPropertiesLoose(props, ["theme", "layerStyle", "textStyle", "apply", "noOfLines", "isTruncated", "css", "__css", "sx"]);

    var _layerStyle = (0, _utils.memoizedGet)(theme, "layerStyles." + layerStyle, {});

    var _textStyle = (0, _utils.memoizedGet)(theme, "textStyles." + textStyle, {}); // filter out props that aren't style props


    var styleProps = (0, _utils.objectFilter)(rest, function (_, prop) {
      return prop in stylePropNames;
    });
    var truncateStyle = {};

    if (noOfLines != null) {
      truncateStyle = {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitBoxOrient: "vertical",
        WebkitLineClamp: noOfLines
      };
    } else if (isTruncated) {
      truncateStyle = {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      };
    }
    /**
     * The computed, theme-aware style object. The other of the properties
     * within `objectAssign` determines how styles are overriden.
     */


    var finalStyles = (0, _utils.objectAssign)({}, __css, baseStyle, {
      apply: apply
    }, _layerStyle, _textStyle, truncateStyle, styleProps, sx); // Converts theme-aware style object to real css object

    var computedCSS = (0, _styledSystem.css)(finalStyles)(props.theme); // Merge the computed css object with styles in css prop

    var cssObject = (0, _utils.objectAssign)(computedCSS, (0, _utils.isFunction)(cssProp) ? cssProp(theme) : cssProp);
    return cssObject;
  };
};

exports.styleResolver = styleResolver;

function styled(component, options) {
  var _ref2 = options != null ? options : {},
      baseStyle = _ref2.baseStyle,
      styledOptions = _objectWithoutPropertiesLoose(_ref2, ["baseStyle"]);

  var opts = _extends({}, styledOptions, {
    shouldForwardProp: _shouldForwardProp.shouldForwardProp
  });

  var styledFn = (0, _styled["default"])(component, opts);
  var args = styleResolver({
    baseStyle: baseStyle
  });
  var StyledComponent = styledFn(args);
  return StyledComponent;
}

var chakra = styled;
exports.chakra = chakra;

_system.domElements.forEach(function (tag) {
  // @ts-expect-error
  chakra[tag] = chakra(tag);
});
//# sourceMappingURL=system.js.map