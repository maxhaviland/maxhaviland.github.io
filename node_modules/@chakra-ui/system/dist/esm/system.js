function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { css, propNames } from "@chakra-ui/styled-system";
import { memoizedGet as get, objectFilter, objectAssign, isFunction } from "@chakra-ui/utils";
import emotionStyled from "@emotion/styled";
import { shouldForwardProp } from "./should-forward-prop";
import { domElements } from "./system.utils";
/**
 * Convert propNames array to object to faster lookup perf
 */

var stylePropNames = propNames.reduce((keymirror, key) => {
  if (typeof key !== "object" && typeof key !== "function") keymirror[key] = key;
  return keymirror;
}, {});

/**
 * Style resolver function that manages how style props are merged
 * in combination with other possible ways of defining styles.
 *
 * For example, take a component defined this way:
 * ```jsx
 * <Box fontSize="24px" sx={{ fontSize: "40px" }}></Box>
 * ```
 *
 * We want to manage the priority of the styles properly to prevent unwanted
 * behaviors. Right now, the `sx` prop has the highest priority so the resolved
 * fontSize will be `40px`
 */
export var styleResolver = (_ref) => {
  var {
    baseStyle
  } = _ref;
  return props => {
    var {
      theme,
      layerStyle,
      textStyle,
      apply,
      noOfLines,
      isTruncated,
      css: cssProp,
      __css,
      sx
    } = props,
        rest = _objectWithoutPropertiesLoose(props, ["theme", "layerStyle", "textStyle", "apply", "noOfLines", "isTruncated", "css", "__css", "sx"]);

    var _layerStyle = get(theme, "layerStyles." + layerStyle, {});

    var _textStyle = get(theme, "textStyles." + textStyle, {}); // filter out props that aren't style props


    var styleProps = objectFilter(rest, (_, prop) => prop in stylePropNames);
    var truncateStyle = {};

    if (noOfLines != null) {
      truncateStyle = {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitBoxOrient: "vertical",
        WebkitLineClamp: noOfLines
      };
    } else if (isTruncated) {
      truncateStyle = {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      };
    }
    /**
     * The computed, theme-aware style object. The other of the properties
     * within `objectAssign` determines how styles are overriden.
     */


    var finalStyles = objectAssign({}, __css, baseStyle, {
      apply
    }, _layerStyle, _textStyle, truncateStyle, styleProps, sx); // Converts theme-aware style object to real css object

    var computedCSS = css(finalStyles)(props.theme); // Merge the computed css object with styles in css prop

    var cssObject = objectAssign(computedCSS, isFunction(cssProp) ? cssProp(theme) : cssProp);
    return cssObject;
  };
};
export function styled(component, options) {
  var _ref2 = options != null ? options : {},
      {
    baseStyle
  } = _ref2,
      styledOptions = _objectWithoutPropertiesLoose(_ref2, ["baseStyle"]);

  var opts = _extends({}, styledOptions, {
    shouldForwardProp
  });

  var styledFn = emotionStyled(component, opts);
  var args = styleResolver({
    baseStyle
  });
  var StyledComponent = styledFn(args);
  return StyledComponent;
}
export var chakra = styled;
domElements.forEach(tag => {
  // @ts-expect-error
  chakra[tag] = chakra(tag);
});
//# sourceMappingURL=system.js.map